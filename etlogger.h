// This file is automatically generated. Please don't edit it.

#pragma once

// #define ETLOGGER_NO_THREAD
// #define ETLOGGER_NO_NETWORK
// #define ETLOGGER_IOSLOG
// #define ETLOGGER_ANDROIDLOG
// #define ETLOGGER_SYSLOG
// #define ETLOGGER_JOURNAL

#define ETLOGGER_DECL_SPEC inline

// etlogger.h

// abstractmessagefilter.h

#include <QSharedPointer>

// abstractmessageprocessor.h

#include <QSharedPointer>

// debugmessage.h

#include <QDateTime>
#include <QMetaType>
#include <QString>
#include <QThread>
#include <qlogging.h>

// logger_global.h

#include <QtCore/qglobal.h>

#if defined(ETLOGGER_STATIC)
#    define ETLOGGER_EXPORT
#elif defined(ETLOGGER_LIBRARY)
#    define ETLOGGER_EXPORT Q_DECL_EXPORT
#else
#    define ETLOGGER_EXPORT Q_DECL_IMPORT
#endif

#if !defined(ETLOGGER_DECL_SPEC)
#    define ETLOGGER_DECL_SPEC
#endif

// end logger_global.h

namespace et {
namespace logger {

class ETLOGGER_EXPORT DebugMessage
{
public:
    DebugMessage() = default;
    DebugMessage(QtMsgType type, const QMessageLogContext &context, const QString &message);
    DebugMessage(const DebugMessage &dmesg);

    QtMsgType type() const;
    const QMessageLogContext &context() const;
    QString message() const;

    int line() const;
    const char *file() const;
    const char *function() const;
    const char *category() const;

    inline QDateTime time() const { return m_time; }
    inline qint64 threadId() const { return reinterpret_cast<qint64>(m_threadId); }

    QString formattedMessage() const;
    void setFormattedMessage(const QString &formattedMessage);
    bool isFormatted() const;

private:
    QtMsgType m_type = QtDebugMsg;
    QMessageLogContext m_context;
    QString m_message;

    // context buffers
    QByteArray m_file;
    QByteArray m_function;
    QByteArray m_category;

    QDateTime m_time = QDateTime::currentDateTime();
    Qt::HANDLE m_threadId = QThread::currentThreadId();

    QString m_formattedMessage;
};

inline QtMsgType DebugMessage::type() const
{
    return m_type;
}

inline const QMessageLogContext &DebugMessage::context() const
{
    return m_context;
}

inline QString DebugMessage::message() const
{
    return m_message;
}

inline int DebugMessage::line() const
{
    return m_context.line;
}

inline const char *DebugMessage::file() const
{
    return m_context.file;
}

inline const char *DebugMessage::function() const
{
    return m_context.function;
}

inline const char *DebugMessage::category() const
{
    return m_context.category;
}

inline QString DebugMessage::formattedMessage() const
{
    return isFormatted() ? m_formattedMessage : m_message;
}

inline void DebugMessage::setFormattedMessage(const QString &formattedMessage)
{
    m_formattedMessage = formattedMessage;
}

inline bool DebugMessage::isFormatted() const
{
    return !m_formattedMessage.isNull();
}

}
}

// end debugmessage.h

class QMessageLogContext;

namespace et {
namespace logger {

class ETLOGGER_EXPORT AbstractMessageProcessor
{
public:
    enum Type { Processor, Filter, Formatter, Sink, Handler };

    virtual ~AbstractMessageProcessor() = default;

    virtual Type processorType() const { return AbstractMessageProcessor::Processor; }

    virtual bool process(DebugMessage &dmesg) = 0;
};

using AbstractMessageProcessorPtr = QSharedPointer<AbstractMessageProcessor>;

} // namespace logger
} // namespace et

// end abstractmessageprocessor.h

class QMessageLogContext;

namespace et {
namespace logger {

class ETLOGGER_EXPORT AbstractMessageFilter : public AbstractMessageProcessor
{
public:
    virtual ~AbstractMessageFilter() = default;

    virtual bool filter(const DebugMessage &dmesg) const = 0;

    Type processorType() const override { return AbstractMessageProcessor::Filter; }

    bool process(DebugMessage &dmesg) override final { return filter(dmesg); }
};

using AbstractMessageFilterPtr = QSharedPointer<AbstractMessageFilter>;

} // namespace logger
} // namespace et

// end abstractmessagefilter.h

// abstractmessageformatter.h

#include <QSharedPointer>

class QMessageLogContext;

namespace et {
namespace logger {

class ETLOGGER_EXPORT AbstractMessageFormatter : public AbstractMessageProcessor
{
public:
    virtual ~AbstractMessageFormatter() = default;

    virtual QString format(const DebugMessage &dmesg) const = 0;

    Type processorType() const override { return AbstractMessageProcessor::Formatter; }

    bool process(DebugMessage &dmesg) override final
    {
        dmesg.setFormattedMessage(format(dmesg));
        return true;
    }
};

using AbstractMessageFormatterPtr = QSharedPointer<AbstractMessageFormatter>;

} // namespace logger
} // namespace et

// end abstractmessageformatter.h

// abstractmessagesink.h

#include <QSharedPointer>

class QMessageLogContext;

namespace et {
namespace logger {

using AbstractMessageSinkPtr = QSharedPointer<class AbstractMessageSink>;

class ETLOGGER_EXPORT AbstractMessageSink : public AbstractMessageProcessor
{
public:
    virtual void send(const DebugMessage &dmesg) = 0;

    virtual bool flush() { return true; }

    Type processorType() const override { return AbstractMessageProcessor::Sink; }

    bool process(DebugMessage &dmesg) override final
    {
        if (!m_preprocessor.isNull()) {
            auto _dmesg = dmesg;
            m_preprocessor->process(_dmesg);
            send(_dmesg);
            return true;
        }

        send(dmesg);

        return true;
    }

    AbstractMessageProcessorPtr preprocessor() const { return m_preprocessor; }

    inline void setPreprocessor(const AbstractMessageProcessorPtr &preprocessor)
    {
        if (preprocessor.data() == this)
            return;

        m_preprocessor = preprocessor;
    }

private:
    AbstractMessageProcessorPtr m_preprocessor;
};

} // namespace logger
} // namespace et

// end abstractmessagesink.h

// functionfilter.h

#include <functional>

#include <QSharedPointer>

namespace et {
namespace logger {

class ETLOGGER_EXPORT FunctionFilter : public AbstractMessageFilter
{
public:
    using Function = std::function<bool(const DebugMessage &)>;

    FunctionFilter(const Function &function);

    bool filter(const DebugMessage &dmesg) const override;

private:
    Function m_function;
};

using FunctionFilterPtr = QSharedPointer<FunctionFilter>;

inline FunctionFilter::FunctionFilter(const Function &function) : m_function(function) { }

inline bool FunctionFilter::filter(const DebugMessage &dmesg) const
{
    return m_function(dmesg);
}

} // namespace logger
} // namespace et

// end functionfilter.h

// regexpfilter.h

#include <QRegularExpression>
#include <QSharedPointer>

namespace et {
namespace logger {

class ETLOGGER_EXPORT RegExpFilter : public AbstractMessageFilter
{
public:
    explicit RegExpFilter(const QRegularExpression &regExp);
    explicit RegExpFilter(const QString &regExp);

    bool filter(const DebugMessage &dmesg) const override;

private:
    QRegularExpression m_regExp;
};

using RegExpFilterPtr = QSharedPointer<RegExpFilter>;

} // namespace logger
} // namespace et

// end regexpfilter.h

// defaultformatter.h

#include <QSharedPointer>

// qtlogmessageformatter.h

#include <QSharedPointer>

namespace et {
namespace logger {

using QtLogMessageFormatterPtr = QSharedPointer<class QtLogMessageFormatter>;

class ETLOGGER_EXPORT QtLogMessageFormatter : public AbstractMessageFormatter
{
public:
    static QtLogMessageFormatterPtr instance()
    {
        static const auto s_instance = QtLogMessageFormatterPtr(new QtLogMessageFormatter());
        return s_instance;
    }

    QString format(const DebugMessage &dmesg) const override
    {
        return qFormatLogMessage(dmesg.type(), dmesg.context(), dmesg.message());
    }

private:
    QtLogMessageFormatter() {}
};

} // namespace logger
} // namespace et

// end qtlogmessageformatter.h

namespace et {
namespace logger {

using DefaultFormatterPtr = QSharedPointer<class DefaultFormatter>;

class ETLOGGER_EXPORT DefaultFormatter : public AbstractMessageProcessor
{
public:
    static DefaultFormatterPtr instance();

    bool process(DebugMessage &dmesg) override;

    AbstractMessageProcessorPtr formatter() const;
    void setFormatter(AbstractMessageProcessorPtr formatter);

private:
    explicit DefaultFormatter(const AbstractMessageProcessorPtr &formatter);

    AbstractMessageProcessorPtr m_formatter;
};

inline DefaultFormatterPtr DefaultFormatter::instance()
{
    static const auto s_instance = DefaultFormatterPtr(new DefaultFormatter(QtLogMessageFormatter::instance()));
    return s_instance;
}

inline DefaultFormatter::DefaultFormatter(const AbstractMessageProcessorPtr &formatter)
    : m_formatter(formatter)
{
}

inline bool DefaultFormatter::process(DebugMessage &dmesg)
{
    if (!dmesg.isFormatted() && m_formatter) {
        m_formatter->process(dmesg);
    }

    return true;
}

inline AbstractMessageProcessorPtr DefaultFormatter::formatter() const
{
    return m_formatter;
}

inline void DefaultFormatter::setFormatter(AbstractMessageProcessorPtr formatter)
{
    m_formatter = formatter;
}

} // namespace logger
} // namespace et

// end defaultformatter.h

// functionformatter.h

#include <functional>

#include <QSharedPointer>

namespace et {
namespace logger {

class ETLOGGER_EXPORT FunctionFormatter : public AbstractMessageFormatter
{
public:
    using Function = std::function<QString(const DebugMessage &)>;

    FunctionFormatter(const Function &func) : m_func(func) { }

    QString format(const DebugMessage &dmesg) const override { return m_func(dmesg); }

private:
    Function m_func;
};

using FunctionFormatterPtr = QSharedPointer<FunctionFormatter>;

} // namespace logger
} // namespace et

// end functionformatter.h

// jsonformatter.h

#include <QSharedPointer>

namespace et {
namespace logger {

using JsonFormatterPtr = QSharedPointer<class JsonFormatter>;

class ETLOGGER_EXPORT JsonFormatter : public AbstractMessageFormatter
{
public:
    static JsonFormatterPtr instance()
    {
        static const auto s_instance = JsonFormatterPtr::create();
        return s_instance;
    }

    QString format(const DebugMessage &dmesg) const override;
};

} // namespace logger
} // namespace et

// end jsonformatter.h

// nullformatter.h

#include <QSharedPointer>

namespace et {
namespace logger {

using NullFormatterPtr = QSharedPointer<class NullFormatter>;

class ETLOGGER_EXPORT NullFormatter : public AbstractMessageFormatter
{
public:
    static NullFormatterPtr instance()
    {
        static const auto s_instance = NullFormatterPtr::create();
        return s_instance;
    }

    QString format(const DebugMessage &dmesg) const override { return dmesg.message(); }
};

} // namespace logger
} // namespace et

// end nullformatter.h

// patternformatter.h

#include <QSharedPointer>

namespace et {
namespace logger {

using PatternFormatterPtr = QSharedPointer<class PatternFormatter>;

class ETLOGGER_EXPORT PatternFormatter : public AbstractMessageFormatter
{
public:
    explicit PatternFormatter(const QString &pattern);

    QString format(const DebugMessage &dmesg) const override;

private:
    QString m_pattern;
};

} // namespace logger
} // namespace et

// end patternformatter.h

// prettyformatter.h

#include <QMap>
#include <QStringList>

namespace et {
namespace logger {

using PrettyFormatterPtr = QSharedPointer<class PrettyFormatter>;

class ETLOGGER_EXPORT PrettyFormatter : public AbstractMessageProcessor
{
public:
    static PrettyFormatterPtr instance()
    {
        static const auto s_instance = PrettyFormatterPtr::create(false, 0);
        return s_instance;
    }

    explicit PrettyFormatter(bool showThread = true, int maxCategoryWidth = 15);

    bool process(DebugMessage &dmesg) override final;

    inline bool showThread() const { return m_showThread; }
    inline void setShowThread(bool newShowThread) { m_showThread = newShowThread; }

    inline int maxCategoryWidth() const { return m_maxCategoryWidth; }
    inline void setMaxCategoryWidth(int newMaxCategoryWidth)
    {
        m_maxCategoryWidth = newMaxCategoryWidth;
    }

private:
    bool m_showThread = true;
    QMap<int, int> m_threads;
    int m_threadsIndex = 0;

    int m_maxCategoryWidth = 15;
    int m_categoryWidth = 0;
};

} // namespace logger
} // namespace et

// end prettyformatter.h

// logger.h

#include <QList>
#include <QObject>
#include <QPointer>
#include <QSettings>

#ifndef ETLOGGER_NO_THREAD
#    include <QEvent>
#    include <QMutex>
#    include <QThread>
#endif

// messagehandler.h

#include <QList>
#include <QSharedPointer>

#include <initializer_list>

namespace et {
namespace logger {

using MessageHandlerPtr = QSharedPointer<class MessageHandler>;

class ETLOGGER_EXPORT MessageHandler : public AbstractMessageProcessor
{
public:
    MessageHandler();
    MessageHandler(std::initializer_list<AbstractMessageProcessorPtr> processors);

    Type processorType() const override { return AbstractMessageProcessor::Handler; }

    void append(const AbstractMessageProcessorPtr &processor);
    void append(std::initializer_list<AbstractMessageProcessorPtr> processors);
    void insertAfter(Type type, const AbstractMessageProcessorPtr &processor);
    void insertAfter(Type type, Type typeRight, const AbstractMessageProcessorPtr &processor);
    void remove(const AbstractMessageProcessorPtr &processor);
    void clear();

    void clear(Type type);

    void appendFilter(const AbstractMessageFilterPtr &filter);
    FunctionFilterPtr appendFilter(const std::function<bool(const DebugMessage &)> &function);
    RegExpFilterPtr appendFilter(const QRegularExpression &regExp);
    void clearFilters();

    void setFormatter(const AbstractMessageFormatterPtr &formatter);
    FunctionFormatterPtr setFormatter(const std::function<QString(const DebugMessage &)> &function);
    PatternFormatterPtr setFormatter(const QString &pattern);
    void clearFormatters();

    void appendSink(const AbstractMessageSinkPtr &sink);
    void clearSinks();

    void appendHandler(const MessageHandlerPtr &handler);
    void clearHandlers();

    MessageHandler &operator<<(const AbstractMessageProcessorPtr &processor);

    bool process(DebugMessage &dmesg) override;

    void flush();

private:
    QList<AbstractMessageProcessorPtr> m_processors;
};

inline MessageHandler &operator<<(MessageHandler *handler,
                                  const AbstractMessageProcessorPtr &processor)
{
    return *handler << processor;
}

inline MessageHandler &operator<<(MessageHandlerPtr handler,
                                  const AbstractMessageProcessorPtr &processor)
{
    return *handler << processor;
}

} // namespace logger
} // namespace et

// end messagehandler.h

#define gEtLogger et::logger::Logger::instance()

#if QT_VERSION >= 0x060000
#define QRMUTEX QRecursiveMutex
#else
#define QRMUTEX QMutex
#endif

namespace et {
namespace logger {

class ETLOGGER_EXPORT Logger : public QObject
{
    Q_OBJECT

public:
    enum SinkTypeFlag {
        None = 0x00,
        StdOut = 0x01,
        StdErr = 0x02,
        SysLog = 0x04,
        Journal = 0x8,
        StdLog = 0x10, // For Android, iOS
        NTEventLog = 0x20,
        File = 0x40,
        RotatingFile = 0x80
    };

    Q_DECLARE_FLAGS(SinkType, SinkTypeFlag)

    static Logger *instance();

    explicit Logger(QObject *parent = nullptr);
    virtual ~Logger();

    /*
        Format:  "[<category>|*].[debug|info|warning|critical]=true|false;..."
        Example: "et.*.debug=false;et.logger.debug=true"
    */
    static void setFilterRules(const QString &rules);

    /*
       Following placeholders are supported:
       %{appname} %{category} %{file} %{function} %{line} %{message} %{pid} %{threadid}
       %{qthreadptr} %{type} %{time process} %{time boot} %{time [format]} %{backtrace [depth=N]
       [separator="..."]}
    */
    static void setMessagePattern(const QString &pattern);

    void append(const AbstractMessageProcessorPtr &processor);
    void append(std::initializer_list<AbstractMessageProcessorPtr> processors);
    void remove(const AbstractMessageProcessorPtr &processor);
    void clear();

    void appendFilter(const AbstractMessageFilterPtr &filter);
    FunctionFilterPtr appendFilter(const std::function<bool(const DebugMessage &)> &function);
    RegExpFilterPtr appendFilter(const QRegularExpression &regExp);
    void clearFilters();

    void setFormatter(const AbstractMessageFormatterPtr &formatter);
    FunctionFormatterPtr setFormatter(const std::function<QString(const DebugMessage &)> &function);
    PatternFormatterPtr setFormatter(const QString &pattern);
    void clearFormatters();

    void appendSink(const AbstractMessageSinkPtr &sink);
    void appendHttpSink(const QString &url, int format);
    void clearSinks();

    void appendHandler(const MessageHandlerPtr &handler);
    void clearHandlers();

    Logger &operator<<(const AbstractMessageProcessorPtr &processor);

    void configure(std::initializer_list<AbstractMessageProcessorPtr> processors,
                   bool async = false);
    void configure(const SinkType &types = StdLog, const QString &path = {}, int maxFileSize = 0,
                   int maxFileCount = 0, bool async = false);
    void configure(int types, const QString &path = {}, int maxFileSize = 0, int maxFileCount = 0,
                   bool async = false);

    /*
       logger/filter_rules = [<category>|*][.debug|.info|.warning|.critical]=true|false;...
       logger/message_pattern = <string>
       logger/regexp_filter = <regexp>
       logger/stdout = true|false
       logger/stderr = true|false
       logger/stdlog = true|false
       logger/syslog_ident = <string>
       logger/journal = true|false
       logger/path = <string>
       logger/max_file_size = <int>
       logger/max_file_count = <int>
       logger/async = true|false
    */
    void configure(const QSettings &settings, const QString &group = QStringLiteral("logger"));
    void configure(const QString &path, const QString &group = QStringLiteral("logger"));

    void flush();

#ifndef ETLOGGER_NO_THREAD
public:
    void lock() const;
    void unlock() const;
    QRMUTEX *mutex() const;

    void moveToOwnThread();
    void moveToMainThread();
    bool ownThreadIsRunning() const;
    inline QThread *ownThread() { return m_thread.data(); }

protected:
    struct LogEvent : public QEvent
    {
        DebugMessage dmesg;

        LogEvent(const DebugMessage &dmesg);
    };

    void customEvent(QEvent *event) override;
#endif

public:
    void installMessageHandler();
    static void restorePreviousMessageHandler();

    static void messageHandler(QtMsgType type, const QMessageLogContext &context,
                               const QString &message);

    void processMessage(QtMsgType type, const QMessageLogContext &context, const QString &message);
    void processMessage(const DebugMessage &dmesg);

private:
    void processMessage(DebugMessage &dmesg);

private:
    MessageHandlerPtr m_handler = MessageHandlerPtr::create();

#ifndef ETLOGGER_NO_THREAD
#if QT_VERSION >= 0x060000
    mutable QRecursiveMutex m_mutex;
#else
    mutable QMutex m_mutex { QMutex::Recursive };
#endif
    QPointer<QThread> m_thread;
#endif
};

inline Logger &operator<<(Logger *logger, const AbstractMessageProcessorPtr &processor)
{
    return *logger << processor;
}

inline Logger& operator<<(Logger* logger, const MessageHandler& handler)
{
    return *logger << MessageHandlerPtr::create(handler);
}

} // namespace logger
} // namespace et

// end logger.h

// messagepatterns.h

namespace et {
namespace logger {

constexpr char DefaultMessagePattern[] = "%{if-category}%{category}: %{endif}"
                                         "%{message}";

constexpr char PrettyMessagePattern[] = "%{time dd.MM.yyyy hh:mm:ss.zzz} "
                                        "%{if-debug} %{endif}"
                                        "%{if-info}I%{endif}"
                                        "%{if-warning}W%{endif}"
                                        "%{if-critical}E%{endif}"
                                        "%{if-fatal}F%{endif} "
                                        "[%{category}] %{message}";

} // namespace logger
} // namespace et

// end messagepatterns.h

// setmessagepattern.h

#include <qlogging.h>

namespace et {
namespace logger {

ETLOGGER_EXPORT QString setMessagePattern(const QString &messagePattern);

ETLOGGER_EXPORT QString restorePreviousMessagePattern();

} // namespace logger
} // namespace et

// end setmessagepattern.h

// filesink.h

#include <QSharedPointer>

// iodevicesink.h

#include <QIODevice>
#include <QSharedPointer>

namespace et {
namespace logger {

using QIODevicePtr = QSharedPointer<QIODevice>;

class ETLOGGER_EXPORT IODeviceSink : public AbstractMessageSink
{
public:
    explicit IODeviceSink(const QIODevicePtr &device);

    void send(const DebugMessage &dmesg) override;

protected:
    const QIODevicePtr &device() const;
    void setDevice(const QIODevicePtr &device);

private:
    QIODevicePtr m_device;
};

using IODeviceSinkPtr = QSharedPointer<IODeviceSink>;

} // namespace logger
} // namespace et

// end iodevicesink.h

class QFile;

namespace et {
namespace logger {

class ETLOGGER_EXPORT FileSink : public IODeviceSink
{
public:
    explicit FileSink(const QString &path);
    ~FileSink() override;

    bool flush() override;

protected:
    QFile *file() const;
};

using FileSinkPtr = QSharedPointer<FileSink>;

} // namespace logger
} // namespace et

// end filesink.h

// rotatingfilesink.h

#include <QSharedPointer>

namespace et {
namespace logger {

constexpr int RotatingFileDefaultMaxFileSize = 1024 * 1024;
constexpr int RotatingFileDefaultMaxFileCount = 3;
constexpr int RotatingFileCountLimit = 1024;

class ETLOGGER_EXPORT RotatingFileSink : public FileSink
{
public:
    explicit RotatingFileSink(const QString &path, int maxFileSize = RotatingFileDefaultMaxFileSize,
                              int maxFileCount = RotatingFileDefaultMaxFileCount);

    void send(const DebugMessage &dmesg) override;

private:
    void rotate();

private:
    int m_maxFileSize = RotatingFileDefaultMaxFileSize;
    int m_maxFileCount = RotatingFileDefaultMaxFileCount;
};

using RotatingFileSinkPtr = QSharedPointer<RotatingFileSink>;

} // namespace logger
} // namespace et

// end rotatingfilesink.h

// signalsink.h

#include <QObject>

namespace et {
namespace logger {

class ETLOGGER_EXPORT SignalSink : public QObject, AbstractMessageSink
{
    Q_OBJECT

public:
    explicit SignalSink(QObject *parent = nullptr);

    void send(const DebugMessage &dmesg) override;

signals:
    void message(const et::logger::DebugMessage &dmesg);
};

using SignalSinkPtr = QSharedPointer<SignalSink>;

} // namespace logger
} // namespace et

// end signalsink.h

// stderrsink.h

#include <QSharedPointer>

namespace et {
namespace logger {

class ETLOGGER_EXPORT StdErrSink : public AbstractMessageSink
{
public:
    StdErrSink();

    void send(const DebugMessage &dmesg) override;
};

using StdErrSinkPtr = QSharedPointer<StdErrSink>;

} // namespace logger
} // namespace et

// end stderrsink.h

// stdlogsink.h

#include <QSharedPointer>

#if defined(ETLOGGER_ANDROIDLOG)

// androidlogsink.h

#ifdef ETLOGGER_ANDROIDLOG

#include <QSharedPointer>

namespace et {
namespace logger {

class ETLOGGER_EXPORT AndroidLogSink : public AbstractMessageSink
{
public:
    AndroidLogSink();

    void send(const DebugMessage &dmesg) override;
};

using AndroidLogSinkPtr = QSharedPointer<AndroidLogSink>;

} // namespace logger
} // namespace et

#endif // ETLOGGER_ANDROIDLOG

// end androidlogsink.h

#elif defined(ETLOGGER_IOSLOG)

// ioslogsink.h

#ifdef ETLOGGER_IOSLOG

#include <QSharedPointer>

namespace et {
namespace logger {

class ETLOGGER_EXPORT IosLogSink : public AbstractMessageSink
{
public:
    IosLogSink();

    void send(const DebugMessage &dmesg);
};

using IosLogSinkPtr = QSharedPointer<IosLogSink>;

} // namespace logger
} // namespace et

#endif // ETLOGGER_IOSLOG

// end ioslogsink.h

#else

#endif

namespace et {
namespace logger {

#if defined(ETLOGGER_ANDROIDLOG)
using StdLogSink = AndroidLogSink;
#elif defined(ETLOGGER_IOSLOG)
using StdLogSink = IosLogSink;
#else
using StdLogSink = StdErrSink;
#endif

using StdLogSinkPtr = QSharedPointer<StdLogSink>;

}
}

// end stdlogsink.h

// stdoutsink.h

#include <QSharedPointer>

namespace et {
namespace logger {

class ETLOGGER_EXPORT StdOutSink : public AbstractMessageSink
{
public:
    StdOutSink();

    void send(const DebugMessage &dmesg) override;
};

using StdOutSinkPtr = QSharedPointer<StdOutSink>;

} // namespace logger
} // namespace et

// end stdoutsink.h

// version.h

#define ETLOGGER_VERSION 0.2.0

// end version.h

using EtAbstractMessageFilter = et::logger::AbstractMessageFilter;
using EtAbstractMessageFormatter = et::logger::AbstractMessageFormatter;
using EtAbstractMessageProcessor = et::logger::AbstractMessageProcessor;
using EtAbstractMessageSink = et::logger::AbstractMessageSink;
using EtDebugMessage = et::logger::DebugMessage;
using EtDefaultFormatter = et::logger::DefaultFormatter;
using EtFileSink = et::logger::FileSink;
using EtFunctionFilter = et::logger::FunctionFilter;
using EtFunctionFormatter = et::logger::FunctionFormatter;
using EtIODeviceSink = et::logger::IODeviceSink;
using EtJsonFormatter = et::logger::JsonFormatter;
using EtLogger = et::logger::Logger;
using EtMessageHandler = et::logger::MessageHandler;
using EtNullFormatter = et::logger::NullFormatter;
using EtPatternFormatter = et::logger::PatternFormatter;
using EtPrettyFormatter = et::logger::PrettyFormatter;
using EtQtLogMessageFormatter = et::logger::QtLogMessageFormatter;
using EtRegExpFilter = et::logger::RegExpFilter;
using EtRotatingFileSink = et::logger::RotatingFileSink;
using EtSignalSink = et::logger::SignalSink;
using EtStdErrSink = et::logger::StdErrSink;
using EtStdLogSink = et::logger::StdLogSink;
using EtStdOutSink = et::logger::StdOutSink;

using EtAbstractMessageFilterPtr = et::logger::AbstractMessageFilterPtr;
using EtAbstractMessageFormatterPtr = et::logger::AbstractMessageFormatterPtr;
using EtAbstractMessageProcessorPtr = et::logger::AbstractMessageProcessorPtr;
using EtAbstractMessageSinkPtr = et::logger::AbstractMessageSinkPtr;
using EtDefaultFormatterPtr = et::logger::DefaultFormatterPtr;
using EtFileSinkPtr = et::logger::FileSinkPtr;
using EtFunctionFilterPtr = et::logger::FunctionFilterPtr;
using EtFunctionFormatterPtr = et::logger::FunctionFormatterPtr;
using EtIODeviceSinkPtr = et::logger::IODeviceSinkPtr;
using EtJsonFormatterPtr = et::logger::JsonFormatterPtr;
using EtMessageHandlerPtr = et::logger::MessageHandlerPtr;
using EtNullFormatterPtr = et::logger::NullFormatterPtr;
using EtPatternFormatterPtr = et::logger::PatternFormatterPtr;
using EtPrettyFormatterPtr = et::logger::PrettyFormatterPtr;
using EtQtLogMessageFormatterPtr = et::logger::QtLogMessageFormatterPtr;
using EtRegExpFilterPtr = et::logger::RegExpFilterPtr;
using EtRotatingFileSinkPtr = et::logger::RotatingFileSinkPtr;
using EtSignalSinkPtr = et::logger::SignalSinkPtr;
using EtStdErrSinkPtr = et::logger::StdErrSinkPtr;
using EtStdLogSinkPtr = et::logger::StdLogSinkPtr;
using EtStdOutSinkPtr = et::logger::StdOutSinkPtr;

using EtFilter = et::logger::AbstractMessageFilter;
using EtFormatter = et::logger::AbstractMessageFormatter;
using EtProcessor = et::logger::AbstractMessageProcessor;
using EtSink = et::logger::AbstractMessageSink;
using EtHandler = et::logger::MessageHandler;

using EtFilterPtr = et::logger::AbstractMessageFilterPtr;
using EtFormatterPtr = et::logger::AbstractMessageFormatterPtr;
using EtProcessorPtr = et::logger::AbstractMessageProcessorPtr;
using EtSinkPtr = et::logger::AbstractMessageSinkPtr;
using EtHandlerPtr = et::logger::MessageHandlerPtr;

#ifndef ETLOGGER_NO_NETWORK

// httpsink.h

#include <QNetworkRequest>
#include <QSharedPointer>
#include <QPointer>
#include <QUrl>

QT_FORWARD_DECLARE_CLASS(QNetworkAccessManager)

namespace et {
namespace logger {

class ETLOGGER_EXPORT HttpSink : public AbstractMessageSink
{
public:
    enum Format {
        None,
        Raw,
        Default,
        Json
    };

    explicit HttpSink(const QUrl &url, Format format = Default);
    ~HttpSink();

    void send(const DebugMessage &dmesg) override;

    void setNetworkAccessManager(QNetworkAccessManager *manager);
    void setRequest(const QNetworkRequest &request);

private:
    QUrl m_url;
    QPointer<QNetworkAccessManager> m_manager;
    QNetworkRequest m_request;
};

using HttpSinkPtr = QSharedPointer<HttpSink>;

} // namespace logger
} // namespace et

// end httpsink.h

using EtHttpSink = et::logger::HttpSink;
using EtHttpSinkPtr = et::logger::HttpSinkPtr;
#endif

#ifdef ETLOGGER_IOSLOG

using EtIosLogSink = et::logger::IosLogSink;
using EtIosLogSinkPtr = et::logger::IosLogSinkPtr;
#endif

#ifdef ETLOGGER_ANDROIDLOG

using EtAndroidLogSink = et::logger::AndroidLogSink;
using EtAndroidLogSinkPtr = et::logger::AndroidLogSinkPtr;
#endif

#ifdef ETLOGGER_SYSLOG

// syslogsink.h

#ifdef ETLOGGER_SYSLOG

#include <QSharedPointer>

#define ET_SYSLOG_LOG_PID  0x01
#define ET_SYSLOG_LOG_USER (1 << 3)

namespace et {
namespace logger {

class ETLOGGER_EXPORT SysLogSink : public AbstractMessageSink
{
public:
    explicit SysLogSink(const QString &ident, int option = ET_SYSLOG_LOG_PID,
                        int facility = ET_SYSLOG_LOG_USER);
    ~SysLogSink();

    void send(const DebugMessage &dmesg) override;
};

using SysLogSinkPtr = QSharedPointer<SysLogSink>;

} // namespace logger
} // namespace et

#endif // ETLOGGER_SYSLOG

// end syslogsink.h

using EtSysLogSink = et::logger::SysLogSink;
using EtSysLogSinkPtr = et::logger::SysLogSinkPtr;
#endif

#ifdef ETLOGGER_JOURNAL

// journalsink.h

#ifdef ETLOGGER_JOURNAL

#include <QSharedPointer>

namespace et {
namespace logger {

class ETLOGGER_EXPORT JournalSink : public AbstractMessageSink
{
public:
    JournalSink();

    void send(const DebugMessage &dmesg) override;
};

using JournalSinkPtr = QSharedPointer<JournalSink>;

} // namespace logger
} // namespace et

#endif // ETLOGGER_JOURNAL

// end journalsink.h

using EtJournalSink = et::logger::JournalSink;
using EtJournalSinkPtr = et::logger::JournalSinkPtr;
#endif

// debugmessage.cpp

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
DebugMessage::DebugMessage(QtMsgType type, const QMessageLogContext &context,
                           const QString &message)
    : m_type(type), m_message(message)
{
    m_context.version = context.version;
    m_context.line = context.line;
    m_context.file = context.file;
    m_context.function = context.function;
    m_context.category = context.category;
}

ETLOGGER_DECL_SPEC
DebugMessage::DebugMessage(const DebugMessage &dmesg)
{
    m_file = QByteArray(dmesg.m_context.file);
    m_function = QByteArray(dmesg.m_context.function);
    m_category = QByteArray(dmesg.m_context.category);

    m_type = dmesg.m_type;
    m_context.version = dmesg.m_context.version;
    m_context.line = dmesg.m_context.line;
    m_context.file = m_file.constData();
    m_context.function = m_function.constData();
    m_context.category = m_category.constData();
    m_message = dmesg.m_message;

    m_time = dmesg.m_time;
    m_threadId = dmesg.m_threadId;

    m_formattedMessage = dmesg.m_formattedMessage;
}

}
}

// regexpfilter.cpp

#include <QRegularExpression>

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
RegExpFilter::RegExpFilter(const QRegularExpression &regExp) : m_regExp(regExp) { }

ETLOGGER_DECL_SPEC
et::logger::RegExpFilter::RegExpFilter(const QString &regExp) : m_regExp(QRegularExpression(regExp))
{
}

ETLOGGER_DECL_SPEC
bool RegExpFilter::filter(const DebugMessage &dmesg) const
{
    return m_regExp.match(dmesg.message()).hasMatch();
}

} // namespace logger
} // namespace et

// jsonformatter.cpp

#include <QCoreApplication>
#include <QHostInfo>
#include <QJsonDocument>
#include <QJsonObject>

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
QString JsonFormatter::format(const DebugMessage &dmesg) const
{
    static QStringList types { QStringLiteral("debug"),    QStringLiteral("warning"),
                               QStringLiteral("critical"), QStringLiteral("fatal"),
                               QStringLiteral("info"),     QStringLiteral("system") };

    QJsonObject obj;

    obj[QStringLiteral("message")] = dmesg.message();
    obj[QStringLiteral("type")] = types.value(dmesg.type(), QStringLiteral("debug"));
    obj[QStringLiteral("line")] = dmesg.line();
    obj[QStringLiteral("file")] = dmesg.file();
    obj[QStringLiteral("function")] = dmesg.function();
    obj[QStringLiteral("category")] = dmesg.category();
    obj[QStringLiteral("time")] = dmesg.time().toString(QStringLiteral("yyyy-MM-ddThh:mm:ss.zZ"));
    obj[QStringLiteral("thread")] = dmesg.threadId();

    if (qApp) {
        obj[QStringLiteral("pid")] = qApp->applicationPid();
        obj[QStringLiteral("app_path")] = qApp->applicationFilePath();
        obj[QStringLiteral("app_name")] = qApp->applicationName();
        obj[QStringLiteral("app_version")] = qApp->applicationVersion();
        obj[QStringLiteral("host_name")] = QHostInfo::localHostName();
    }

    return QJsonDocument(obj).toJson();
}

} // namespace logger
} // namespace et

// patternformatter.cpp

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
PatternFormatter::PatternFormatter(const QString &pattern) : m_pattern(pattern) { }

ETLOGGER_DECL_SPEC
QString PatternFormatter::format(const DebugMessage &dmesg) const
{
    // TODO: write own formatter

    et::logger::setMessagePattern(m_pattern);

    auto result = qFormatLogMessage(dmesg.type(), dmesg.context(), dmesg.message());

    et::logger::restorePreviousMessagePattern();

    return result;
}

} // namespace logger
} // namespace et

// prettyformatter.cpp

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
PrettyFormatter::PrettyFormatter(bool showThread, int maxCategoryWidth)
    : m_showThread(showThread), m_maxCategoryWidth(maxCategoryWidth)
{
}

ETLOGGER_DECL_SPEC
bool PrettyFormatter::process(DebugMessage &dmesg)
{
    static const QString msg_f { QStringLiteral("%1 %2 %3%4%5%6") };
    static const QString time_f { QStringLiteral("dd.MM.yyyy hh:mm:ss.zzz") };
    static const QStringList type_l { " ", "W", "E", "F", "I", "S" };
    static const QString thread_f { QStringLiteral("#%1 ") };
    static const QString category_f { QStringLiteral("[%1] ") };

    QString thread;
    if (m_showThread) {
        if (!m_threads.contains(dmesg.threadId())) {
            m_threads[dmesg.threadId()] = m_threadsIndex++;
        }
        if (m_threads.count() > 1) {
            const auto index = m_threads.value(dmesg.threadId());
            thread = thread_f.arg(index);
            if (index == 0) {
                thread.fill(' ');
            }
        }
    }

    QString category;
    if (qstrcmp(dmesg.category(), "default") != 0) {
        category = category_f.arg(dmesg.category());
    }

    QString space;
    if (m_maxCategoryWidth > 0) {
        int categoryLength = category.length();
        if (categoryLength > m_categoryWidth && categoryLength <= m_maxCategoryWidth) {
            m_categoryWidth = categoryLength;
        }
        space.fill(' ', qMax(m_categoryWidth - categoryLength, 0));
    }

    auto result = msg_f.arg(dmesg.time().toString(time_f), type_l.at(dmesg.type()), thread,
                            category, space, dmesg.message());

    dmesg.setFormattedMessage(result);

    return true;
}

} // namespace logger
} // namespace et

// logger.cpp

#include <QFileInfo>
#include <QLoggingCategory>
#include <QScopedPointer>

#ifndef ETLOGGER_NO_THREAD
#    include <QAtomicPointer>
#    include <QCoreApplication>
#    include <QMutexLocker>
#endif

#include <iostream>

#ifndef ETLOGGER_NO_NETWORK

#endif

#ifdef ETLOGGER_SYSLOG

#endif

#ifdef ETLOGGER_JOURNAL

#endif

#ifdef ETLOGGER_IOSLOG

#endif

#ifdef ETLOGGER_ANDROIDLOG

#endif

namespace et {
namespace logger {

namespace {

#ifndef ETLOGGER_NO_THREAD
QAtomicPointer<Logger> g_activeLogger;
#else
Logger *g_activeLogger = nullptr;
#endif

QtMessageHandler g_previousMessageHandler = nullptr;

}

ETLOGGER_DECL_SPEC
Logger *Logger::instance()
{
    static QScopedPointer<Logger> s_instance;

    if (!s_instance) {
        s_instance.reset(new Logger);
        s_instance->installMessageHandler();
    }

    return s_instance.data();
}

ETLOGGER_DECL_SPEC
Logger::Logger(QObject *parent) : QObject(parent)
{
    qRegisterMetaType<et::logger::DebugMessage>("et::logger::DebugMessage");
}

ETLOGGER_DECL_SPEC
Logger::~Logger()
{
#ifndef ETLOGGER_NO_THREAD
    g_activeLogger.testAndSetOrdered(this, nullptr);
#else
    if (g_activeLogger == this) {
        g_activeLogger = nullptr;
    }
#endif

    flush();

#ifndef ETLOGGER_NO_THREAD
    if (m_thread) {
        m_thread->quit();
    }
#endif
}

ETLOGGER_DECL_SPEC
void Logger::setFilterRules(const QString &rules)
{
    QLoggingCategory::setFilterRules(QString(rules).replace(';', '\n'));
}

ETLOGGER_DECL_SPEC
void Logger::setMessagePattern(const QString &pattern)
{
    if (pattern.toLower() == "default") {
        et::logger::setMessagePattern(DefaultMessagePattern);
        return;
    }

    if (pattern.toLower() == "et_pretty") {
        et::logger::setMessagePattern(PrettyMessagePattern);
        return;
    }

    et::logger::setMessagePattern(pattern);
}

ETLOGGER_DECL_SPEC
void Logger::append(const AbstractMessageProcessorPtr &processor)
{
    m_handler->append(processor);
}

ETLOGGER_DECL_SPEC
void Logger::append(std::initializer_list<AbstractMessageProcessorPtr> processors)
{
    m_handler->append(processors);
}

ETLOGGER_DECL_SPEC
void Logger::remove(const AbstractMessageProcessorPtr &processor)
{
    m_handler->remove(processor);
}

ETLOGGER_DECL_SPEC
void Logger::clear()
{
    m_handler->clear();
}

ETLOGGER_DECL_SPEC
void Logger::appendFilter(const AbstractMessageFilterPtr &filter)
{
    m_handler->appendFilter(filter);
}

ETLOGGER_DECL_SPEC
FunctionFilterPtr Logger::appendFilter(const FunctionFilter::Function &function)
{
    return m_handler->appendFilter(function);
}

ETLOGGER_DECL_SPEC
RegExpFilterPtr Logger::appendFilter(const QRegularExpression &regExp)
{
    return m_handler->appendFilter(regExp);
}

ETLOGGER_DECL_SPEC
void Logger::clearFilters()
{
    m_handler->clearFilters();
}

ETLOGGER_DECL_SPEC
void Logger::setFormatter(const AbstractMessageFormatterPtr &formatter)
{
    m_handler->setFormatter(formatter);
}

ETLOGGER_DECL_SPEC
FunctionFormatterPtr Logger::setFormatter(const FunctionFormatter::Function &function)
{
    return m_handler->setFormatter(function);
}

ETLOGGER_DECL_SPEC
PatternFormatterPtr Logger::setFormatter(const QString &pattern)
{
    return m_handler->setFormatter(pattern);
}

ETLOGGER_DECL_SPEC
void Logger::clearFormatters()
{
    m_handler->clearFormatters();
}

ETLOGGER_DECL_SPEC
void Logger::appendSink(const AbstractMessageSinkPtr &sink)
{
    m_handler->appendSink(sink);
}

ETLOGGER_DECL_SPEC
void Logger::appendHttpSink(const QString &url, int format)
{
    appendSink(HttpSinkPtr::create(QUrl(url), static_cast<HttpSink::Format>(format)));
}

ETLOGGER_DECL_SPEC
void Logger::clearSinks()
{
    m_handler->clearSinks();
}

ETLOGGER_DECL_SPEC
void Logger::appendHandler(const MessageHandlerPtr &handler)
{
    m_handler->appendHandler(handler);
}

ETLOGGER_DECL_SPEC
void Logger::clearHandlers()
{
    m_handler->clearHandlers();
}

ETLOGGER_DECL_SPEC
Logger &Logger::operator<<(const AbstractMessageProcessorPtr &processor)
{
    append(processor);
    return *this;
}

ETLOGGER_DECL_SPEC
void Logger::configure(std::initializer_list<AbstractMessageProcessorPtr> processors, bool async)
{
#ifndef ETLOGGER_NO_THREAD
    QMutexLocker locker(&m_mutex);
#endif

    m_handler = MessageHandlerPtr::create(processors);

#ifndef ETLOGGER_NO_THREAD
    if (async) {
        moveToOwnThread();
    }
#else
    Q_UNUSED(async)
#endif
}

ETLOGGER_DECL_SPEC
void Logger::configure(const SinkType &types, const QString &path, int maxFileSize,
                       int maxFileCount, bool async)
{
#ifndef ETLOGGER_NO_THREAD
    QMutexLocker locker(&m_mutex);
#endif

    clear();

    DefaultFormatter::instance()->setFormatter(PrettyFormatter::instance());

    if (types.testFlag(StdOut)) {
        appendSink(StdOutSinkPtr::create());
    }

    if (types.testFlag(StdErr)) {
        appendSink(StdErrSinkPtr::create());
    }

    if (types.testFlag(StdLog)) {
        appendSink(StdLogSinkPtr::create());
    }

#ifdef ETLOGGER_SYSLOG
    if (types.testFlag(SysLog)) {
        appendSink(SysLogSinkPtr::create(QFileInfo(path).baseName()));
    }
#endif

#ifdef ETLOGGER_JOURNAL
    if (types.testFlag(Journal)) {
        appendSink(JournalSinkPtr::create());
    }
#endif

    if (types.testFlag(File) && !path.isEmpty()) {
        appendSink(FileSinkPtr::create(path));
    }

    if (types.testFlag(RotatingFile) && !path.isEmpty()) {
        appendSink(RotatingFileSinkPtr::create(path, maxFileSize, maxFileCount));
    }

#ifndef ETLOGGER_NO_THREAD
    if (async) {
        moveToOwnThread();
    }
#else
    Q_UNUSED(async)
#endif
}

ETLOGGER_DECL_SPEC
void Logger::configure(int types, const QString &path, int maxFileSize, int maxFileCount,
                       bool async)
{
    configure(SinkType(QFlag(types)), path, maxFileSize, maxFileCount, async);
}

ETLOGGER_DECL_SPEC
void Logger::configure(const QSettings &settings, const QString &group)
{
#ifndef ETLOGGER_NO_THREAD
    QMutexLocker locker(&m_mutex);
#endif

    clear();

    DefaultFormatter::instance()->setFormatter(PrettyFormatter::instance());

    const auto filterRules = settings.value(group + QStringLiteral("/filter_rules")).toString();
    if (!filterRules.isEmpty()) {
#ifdef ETLOGGER_DEBUG
        std::cerr << "Logger::configure: filterRules: " << filterRules.toStdString() << std::endl;
#endif
        setFilterRules(filterRules);
    }

    const auto messagePattern = settings.value(group + QStringLiteral("/message_pattern")).toString();
    if (!messagePattern.isEmpty()) {
#ifdef ETLOGGER_DEBUG
        std::cerr << "Logger::configure: messagePattern: " << messagePattern.toStdString()
                  << std::endl;
#endif
        DefaultFormatter::instance()->setFormatter(QtLogMessageFormatter::instance());
        setMessagePattern(messagePattern);
    }

    const auto regExpFilter = settings.value(group + QStringLiteral("/regexp_filter")).toString();
    if (!regExpFilter.isEmpty()) {
#ifdef ETLOGGER_DEBUG
        std::cerr << "Logger::configure: filter: " << regExpFilter.toStdString() << std::endl;
#endif
        appendFilter(RegExpFilterPtr::create(regExpFilter));
    }

    if (settings.value(group + QStringLiteral("/stdout"), false).toBool()) {
        std::cerr << "Logger::configure: stdout" << std::endl;
        appendSink(StdOutSinkPtr::create());
    }

    if (settings.value(group + QStringLiteral("/stderr"), false).toBool()) {
#ifdef ETLOGGER_DEBUG
        std::cerr << "Logger::configure: stderr" << std::endl;
#endif
        appendSink(StdErrSinkPtr::create());
    }

    if (settings.value(group + QStringLiteral("/stdlog"), true).toBool()) {
#ifdef ETLOGGER_DEBUG
        std::cerr << "Logger::configure: stdlog" << std::endl;
#endif
        appendSink(StdLogSinkPtr::create());
    }

#ifdef ETLOGGER_SYSLOG
    const auto sysLogIdent = settings.value(group + QStringLiteral("/syslog_ident")).toString();
    if (!sysLogIdent.isEmpty()) {
#    ifdef ETLOGGER_DEBUG
        std::cerr << "Logger::configure: sysLogIdent: " << sysLogIdent.toStdString() << std::endl;
#    endif
        appendSink(SysLogSinkPtr::create(sysLogIdent));
    }
#endif

#ifdef ETLOGGER_JOURNAL
    if (settings.value(group + QStringLiteral("/journal"), false).toBool()) {
#    ifdef ETLOGGER_DEBUG
        std::cerr << "Logger::configure: journal" << std::endl;
#    endif
        appendSink(JournalSinkPtr::create());
    }
#endif

    const auto path = settings.value(group + QStringLiteral("/path")).toString();
    if (!path.isEmpty()) {
        const auto maxFileSize = settings.value(group + QStringLiteral("/max_file_size"),
                                                RotatingFileDefaultMaxFileSize)
                                         .toInt();

        const auto maxFileCount = settings.value(group + QStringLiteral("/max_file_count"),
                                                 RotatingFileDefaultMaxFileCount)
                                          .toInt();

#ifdef ETLOGGER_DEBUG
        std::cerr << "Logger::configure: path: " << path.toStdString()
                  << " maxFileSize: " << maxFileSize << " maxFileCount: " << maxFileCount
                  << std::endl;
#endif

        appendSink(RotatingFileSinkPtr::create(path, maxFileSize, maxFileCount));
    }

#ifndef ETLOGGER_NO_NETWORK
    const auto httpUrl = settings.value(group + QStringLiteral("/http_url")).toString();
    if (!httpUrl.isEmpty()) {
        const auto httpMsgFormat =
                settings.value(group + QStringLiteral("/http_msg_format"), QStringLiteral("default"))
                        .toString();
        static QMap<QString, HttpSink::Format> formats {
            { QStringLiteral("raw"), HttpSink::Raw },
            { QStringLiteral("default"), HttpSink::Default },
            { QStringLiteral("json"), HttpSink::Json },
        };
        appendSink(HttpSinkPtr::create(QUrl(httpUrl),
                                       formats.value(httpMsgFormat, HttpSink::Default)));
    }
#endif

#ifndef ETLOGGER_NO_THREAD
    if (settings.value(group + QStringLiteral("/async"), false).toBool()) {
#    ifdef ETLOGGER_DEBUG
        std::cerr << "Logger::configure: async" << std::endl;
#    endif
        moveToOwnThread();
    }
#endif
}

ETLOGGER_DECL_SPEC
void Logger::configure(const QString &path, const QString &group)
{
    configure(QSettings(path, QSettings::IniFormat), group);
}

ETLOGGER_DECL_SPEC
void Logger::flush()
{
    m_handler->flush();
}

#ifndef ETLOGGER_NO_THREAD

ETLOGGER_DECL_SPEC
void Logger::lock() const
{
    m_mutex.lock();
}

ETLOGGER_DECL_SPEC
void Logger::unlock() const
{
    m_mutex.unlock();
}

ETLOGGER_DECL_SPEC
QRMUTEX *Logger::mutex() const
{
    return &m_mutex;
}

ETLOGGER_DECL_SPEC
void Logger::moveToOwnThread()
{
    if (!m_thread) {
        m_thread = new QThread;
        if (qApp) {
            if (qApp->thread() != m_thread->thread())
                m_thread->moveToThread(qApp->thread());
            connect(qApp, &QCoreApplication::aboutToQuit, m_thread, &QThread::quit);
        }
        connect(m_thread, &QThread::finished, m_thread, &QThread::deleteLater);
        m_thread->start();
    }

    moveToThread(m_thread);
}

ETLOGGER_DECL_SPEC
void Logger::moveToMainThread()
{
    moveToThread(qApp->thread());

    if (m_thread) {
        m_thread->quit();
    }
}

ETLOGGER_DECL_SPEC
bool Logger::ownThreadIsRunning() const
{
    return m_thread && m_thread->isRunning();
}

namespace {

ETLOGGER_DECL_SPEC
static QEvent::Type etLogEventType()
{
    // TODO: QEvent::registerEventType()
    static const QEvent::Type type = static_cast<QEvent::Type>(QEvent::User + 1000);
    return type;
}

}

ETLOGGER_DECL_SPEC
Logger::LogEvent::LogEvent(const DebugMessage &dmesg) : QEvent(etLogEventType()), dmesg(dmesg) { }

ETLOGGER_DECL_SPEC
void Logger::customEvent(QEvent *event)
{
    if (event->type() == etLogEventType()) {
        auto ev = dynamic_cast<LogEvent *>(event);
        if (ev) {
            m_handler->process(ev->dmesg);
        }
    }
}

#endif

ETLOGGER_DECL_SPEC
void Logger::processMessage(DebugMessage &dmesg)
{
    m_handler->process(dmesg);
}

ETLOGGER_DECL_SPEC
void Logger::processMessage(const DebugMessage &dmesg)
{
    DebugMessage __dmesg(dmesg);
    processMessage(__dmesg);
}

ETLOGGER_DECL_SPEC
void Logger::processMessage(QtMsgType type, const QMessageLogContext &context,
                            const QString &message)
{
    DebugMessage dmesg(type, context, message);

#ifndef ETLOGGER_NO_THREAD
    if (!ownThreadIsRunning()) {
        processMessage(dmesg);
    } else {
        QCoreApplication::postEvent(this, new LogEvent(dmesg));
    }
#else
    processMessage(dmesg);
#endif
}

ETLOGGER_DECL_SPEC
void Logger::messageHandler(QtMsgType type, const QMessageLogContext &context,
                            const QString &message)
{
#ifndef ETLOGGER_NO_THREAD
    auto logger = g_activeLogger.loadAcquire();
#else
    auto logger = g_activeLogger;
#endif

    if (!logger)
        return;

#ifndef ETLOGGER_NO_THREAD
    QMutexLocker locker(logger->mutex());
#endif

    logger->processMessage(type, context, message);
}

ETLOGGER_DECL_SPEC
void Logger::installMessageHandler()
{
#ifndef ETLOGGER_NO_THREAD
    g_activeLogger.storeRelease(this);
#else
    g_activeLogger = this;
#endif

    auto prev = qInstallMessageHandler(messageHandler);

    if (prev != messageHandler) {
        g_previousMessageHandler = prev;
    }
}

ETLOGGER_DECL_SPEC
void Logger::restorePreviousMessageHandler()
{
    if (!g_previousMessageHandler)
        return;

    auto prev = qInstallMessageHandler(g_previousMessageHandler);

    if (prev != messageHandler) {
        qInstallMessageHandler(prev);
    }

    g_previousMessageHandler = nullptr;
}

} // namespace logger
} // namespace et

// messagehandler.cpp

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
MessageHandler::MessageHandler() { }

ETLOGGER_DECL_SPEC
MessageHandler::MessageHandler(std::initializer_list<AbstractMessageProcessorPtr> processors)
    : m_processors(processors)
{
}

ETLOGGER_DECL_SPEC
void MessageHandler::append(const AbstractMessageProcessorPtr &processor)
{
    if (processor.isNull())
        return;

    m_processors.append(processor);
}

ETLOGGER_DECL_SPEC
void MessageHandler::append(std::initializer_list<AbstractMessageProcessorPtr> processors)
{
    m_processors.append(processors);
}

ETLOGGER_DECL_SPEC
void MessageHandler::insertAfter(Type type, const AbstractMessageProcessorPtr &processor)
{
    auto first = std::find_if(m_processors.begin(), m_processors.end(),
                              [type](const auto &x) { return x->processorType() == type; });

    if (first == m_processors.end()) {
        m_processors.prepend(processor);
        return;
    }

    auto last = std::find_if(first, m_processors.end(),
                             [type](const auto &x) { return x->processorType() != type; });

    m_processors.insert(last, processor);
}

ETLOGGER_DECL_SPEC
void MessageHandler::insertAfter(Type type, Type typeRight,
                                 const AbstractMessageProcessorPtr &processor)
{
    auto first = std::find_if(m_processors.begin(), m_processors.end(),
                              [type](const auto &x) { return x->processorType() == type; });

    if (first == m_processors.end()) {

        auto right = std::find_if(first, m_processors.end(), [typeRight](const auto &x) {
            return x->processorType() == typeRight;
        });

        if (first != m_processors.end()) {
            m_processors.insert(--right, processor);
        } else {
            m_processors.prepend(processor);
        }

        return;
    }

    auto last = std::find_if(first, m_processors.end(),
                             [type](const auto &x) { return x->processorType() != type; });

    m_processors.insert(last, processor);
}

ETLOGGER_DECL_SPEC
void MessageHandler::remove(const AbstractMessageProcessorPtr &processor)
{
    if (processor.isNull())
        return;

    m_processors.removeAll(processor);
}

ETLOGGER_DECL_SPEC
void MessageHandler::clear()
{
    m_processors.clear();
}

ETLOGGER_DECL_SPEC
void MessageHandler::clear(Type type)
{
    QMutableListIterator<AbstractMessageProcessorPtr> iter(m_processors);

    while (iter.hasNext()) {
        if (iter.next()->processorType() == type) {
            iter.remove();
        }
    }
}

ETLOGGER_DECL_SPEC
void MessageHandler::appendFilter(const AbstractMessageFilterPtr &filter)
{
    if (filter.isNull())
        return;

    auto index = std::find_if(m_processors.begin(), m_processors.end(), [](const auto &x) {
        return x->processorType() != AbstractMessageProcessor::Filter;
    });

    m_processors.insert(index, filter);
}

ETLOGGER_DECL_SPEC
FunctionFilterPtr
MessageHandler::appendFilter(const std::function<bool(const DebugMessage &)> &function)
{
    const auto f = FunctionFilterPtr::create(function);

    appendFilter(f);

    return f;
}

ETLOGGER_DECL_SPEC
RegExpFilterPtr MessageHandler::appendFilter(const QRegularExpression &regExp)
{
    const auto f = RegExpFilterPtr::create(regExp);

    appendFilter(f);

    return f;
}

ETLOGGER_DECL_SPEC
void MessageHandler::clearFilters()
{
    clear(Filter);
}

ETLOGGER_DECL_SPEC
void MessageHandler::setFormatter(const AbstractMessageFormatterPtr &formatter)
{
    if (formatter.isNull())
        return;

    clearFormatters();

    auto index = std::find_if(m_processors.begin(), m_processors.end(), [](const auto &x) {
        return x->processorType() != AbstractMessageProcessor::Filter;
    });

    m_processors.insert(index, formatter);
}

ETLOGGER_DECL_SPEC
FunctionFormatterPtr MessageHandler::setFormatter(const FunctionFormatter::Function &function)
{
    const auto f = FunctionFormatterPtr::create(function);

    setFormatter(f);

    return f;
}

ETLOGGER_DECL_SPEC
PatternFormatterPtr MessageHandler::setFormatter(const QString &pattern)
{
    const auto f = PatternFormatterPtr::create(pattern);

    setFormatter(f);

    return f;
}

ETLOGGER_DECL_SPEC
void MessageHandler::clearFormatters()
{
    clear(AbstractMessageProcessor::Formatter);
}

ETLOGGER_DECL_SPEC
void MessageHandler::appendSink(const AbstractMessageSinkPtr &sink)
{
    append(sink);
}

ETLOGGER_DECL_SPEC
void MessageHandler::clearSinks()
{
    clear(AbstractMessageProcessor::Sink);
}

ETLOGGER_DECL_SPEC
void MessageHandler::appendHandler(const MessageHandlerPtr &handler)
{
    append(handler);
}

ETLOGGER_DECL_SPEC
void MessageHandler::clearHandlers()
{
    clear(AbstractMessageProcessor::Handler);
}

ETLOGGER_DECL_SPEC
MessageHandler &MessageHandler::operator<<(const AbstractMessageProcessorPtr &processor)
{
    append(processor);
    return *this;
}

ETLOGGER_DECL_SPEC
bool MessageHandler::process(DebugMessage &dmesg)
{
    for (auto &processor : m_processors) {
        if (!processor)
            continue;
        if (!processor->process(dmesg))
            break;
    }

    return true;
}

ETLOGGER_DECL_SPEC
void MessageHandler::flush()
{
    for (auto &processor : m_processors) {
        switch (processor->processorType()) {
        case AbstractMessageProcessor::Sink: {
            auto sink = processor.dynamicCast<AbstractMessageSink>();
            if (sink)
                sink->flush();
            break;
        }
        case AbstractMessageProcessor::Handler: {
            auto handler = processor.dynamicCast<MessageHandler>();
            if (handler)
                handler->flush();
            break;
        }
        default:
            break;
        }
    }
}

} // namespace logger
} // namespace et

// setmessagepattern.cpp

#include <QString>

namespace {

ETLOGGER_DECL_SPEC
QString prevMessagePattern(const QString &messagePattern = {})
{
    static QString __prevMessagePattern { et::logger::DefaultMessagePattern };

    if (!messagePattern.isNull())
        __prevMessagePattern = messagePattern;

    return __prevMessagePattern;
}

}

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
QString setMessagePattern(const QString &messagePattern)
{
    static QString __messagePattern { DefaultMessagePattern };

    if (__messagePattern == messagePattern)
        return __messagePattern;

    prevMessagePattern(__messagePattern);

    __messagePattern = messagePattern;

    qSetMessagePattern(__messagePattern);

    return prevMessagePattern();
}

ETLOGGER_DECL_SPEC
QString restorePreviousMessagePattern()
{
    return setMessagePattern(prevMessagePattern());
}

} // namespace logger
} // namespace et

// androidlogsink.cpp

#ifdef ETLOGGER_ANDROIDLOG

#ifdef ETLOGGER_ANDROIDLOG
#    include <android/log.h>
#endif

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
AndroidLogSink::AndroidLogSink() {}

ETLOGGER_DECL_SPEC
void AndroidLogSink::send(const DebugMessage &dmesg)
{
#ifdef ETLOGGER_ANDROIDLOG
    android_LogPriority priority = ANDROID_LOG_DEBUG;
    switch (dmesg.type()) {
    case QtDebugMsg:
        priority = ANDROID_LOG_DEBUG;
        break;
    case QtInfoMsg:
        priority = ANDROID_LOG_INFO;
        break;
    case QtWarningMsg:
        priority = ANDROID_LOG_WARN;
        break;
    case QtCriticalMsg:
        priority = ANDROID_LOG_ERROR;
        break;
    case QtFatalMsg:
        priority = ANDROID_LOG_FATAL;
        break;
    };

    __android_log_print(priority, dmesg.category(), "%s\n", qPrintable(dmesg.message()));
#else
    Q_UNUSED(dmesg);
#endif
}

} // namespace logger
} // namespace et

#endif // ETLOGGER_ANDROIDLOG

// filesink.cpp

#include <QDateTime>
#include <QFile>
#include <QRegularExpression>
#include <QSharedPointer>

#include <iostream>

namespace et {
namespace logger {

namespace {

ETLOGGER_DECL_SPEC
QString replaceTimePattern(const QString &str)
{
    static auto re = QRegularExpression("(.*)%{time *(.*?)}(.*)");
    auto match = re.match(str);

    if (!match.hasMatch())
        return str;

    auto format = match.captured(2);

    if (format.isEmpty()) {
        format = "yyyyMMdd_hhmmss";
    }

    return match.captured(1) + QDateTime::currentDateTime().toString(format) + match.captured(3);
}

ETLOGGER_DECL_SPEC
QSharedPointer<QFile> createFilePtr(const QString &path)
{
    return QSharedPointer<QFile>::create(replaceTimePattern(path));
}

}

ETLOGGER_DECL_SPEC
FileSink::FileSink(const QString &path) : IODeviceSink(createFilePtr(path))
{
    if (!file()->open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text)) {
        std::cerr << "Logger::FileHandler: Can't open log file: " << path.toStdString()
                  << " error: " << file()->errorString().toStdString() << std::endl;
    }
}

ETLOGGER_DECL_SPEC
FileSink::~FileSink()
{
    file()->close();
}

ETLOGGER_DECL_SPEC
bool FileSink::flush()
{
    return file()->flush();
}

ETLOGGER_DECL_SPEC
QFile *FileSink::file() const
{
    return qobject_cast<QFile *>(device().data());
}

} // namespace logger
} // namespace et

// httpsink.cpp

#ifndef ETLOGGER_NO_NETWORK

#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QNetworkRequest>

#include <iostream>

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
HttpSink::HttpSink(const QUrl &url, Format format)
    : m_url(url)
{
    m_manager = new QNetworkAccessManager;

#ifndef ETLOGGER_NO_THREAD
    if (m_manager->thread() != Logger::instance()->thread()) {
        m_manager->moveToThread(Logger::instance()->thread());
    }
#endif
    m_manager->setParent(Logger::instance());

    switch (format) {
    case None:
        setPreprocessor(nullptr);
        break;
    case Raw:
        setPreprocessor(NullFormatter::instance());
        break;
    case Default:
        setPreprocessor(DefaultFormatter::instance());
        break;
    case Json:
        setPreprocessor(JsonFormatter::instance());
        break;
    }

    m_request.setUrl(m_url);

    if (format == Json) {
        m_request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json; charset=utf-8");
    }
    else {
        m_request.setHeader(QNetworkRequest::ContentTypeHeader, "text/plain; charset=utf-8");
    }
}

ETLOGGER_DECL_SPEC
HttpSink::~HttpSink() {
    if (!m_manager.isNull()) {
        delete m_manager.data();
    }
}

ETLOGGER_DECL_SPEC
void HttpSink::send(const DebugMessage &dmesg)
{
    if (!Logger::instance()->ownThreadIsRunning()) {
        if (!m_manager.isNull() && !m_manager->property("activeReply").isValid())
            m_manager->deleteLater();
        m_manager = new QNetworkAccessManager;
    }

    auto reply = m_manager->post(m_request, dmesg.formattedMessage().toUtf8());

    QObject::connect(reply, &QNetworkReply::finished, reply, &QObject::deleteLater);

    if (!Logger::instance()->ownThreadIsRunning()) {
        m_manager->setProperty("activeReply", QVariant::fromValue(reply));
        QObject::connect(reply, &QNetworkReply::finished, m_manager, &QObject::deleteLater);
    }
}

ETLOGGER_DECL_SPEC
void HttpSink::setNetworkAccessManager(QNetworkAccessManager *manager)
{
    if (!m_manager.isNull()) {
        delete m_manager.data();
    }
    m_manager = manager;
}

ETLOGGER_DECL_SPEC
void HttpSink::setRequest(const QNetworkRequest &request)
{
    m_request = request;
}

} // namespace logger
} // namespace et

#endif // ETLOGGER_NO_NETWORK

// iodevicesink.cpp

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
IODeviceSink::IODeviceSink(const QIODevicePtr &device) : m_device(device)
{
    setPreprocessor(DefaultFormatter::instance());
}

ETLOGGER_DECL_SPEC
void IODeviceSink::send(const DebugMessage &dmesg)
{
    if (m_device.isNull()) {
        return;
    }

    m_device->write(dmesg.formattedMessage().toLocal8Bit().append("\n"));
}

ETLOGGER_DECL_SPEC
const QIODevicePtr &IODeviceSink::device() const
{
    return m_device;
}

ETLOGGER_DECL_SPEC
void IODeviceSink::setDevice(const QIODevicePtr &device)
{
    m_device = device;
}

} // namespace logger
} // namespace et

// ioslogsink.cpp

#ifdef ETLOGGER_IOSLOG

#ifdef ETLOGGER_IOSLOG
#    include <os/log.h>
#endif

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
IosLogSink::IosLogSink() { }

ETLOGGER_DECL_SPEC
void IosLogSink::send(const DebugMessage &dmesg)
{
#ifdef ETLOGGER_IOSLOG
    QString formattedMessage;
    if (qstrcmp(dmesg.category(), "default") == 0)
        formattedMessage = dmesg.message();
    else
        formattedMessage = QStringLiteral("%1: %2").arg(dmesg.category(), dmesg.message());

    os_log_type_t type = OS_LOG_TYPE_DEBUG;
    switch (dmesg.type()) {
    case QtDebugMsg:
        type = OS_LOG_TYPE_DEBUG;
        break;
    case QtInfoMsg:
        type = OS_LOG_TYPE_INFO;
        break;
    case QtWarningMsg:
        type = OS_LOG_TYPE_ERROR;
        break;
    case QtCriticalMsg:
        type = OS_LOG_TYPE_FAULT;
        break;
    case QtFatalMsg:
        type = OS_LOG_TYPE_FAULT;
        break;
    };

    os_log_with_type(OS_LOG_DEFAULT, type, "%s\n", qPrintable(dmesg.message()));
#else
    Q_UNUSED(dmesg);
#endif
}

} // namespace logger
} // namespace et

#endif // ETLOGGER_IOSLOG

// journalsink.cpp

#ifdef ETLOGGER_JOURNAL

#ifdef ETLOGGER_JOURNAL
#    include <systemd/sd-journal.h>
#endif

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
JournalSink::JournalSink()
{
    setPreprocessor(NullFormatter::instance());
}

ETLOGGER_DECL_SPEC
void JournalSink::send(const DebugMessage &dmesg)
{
#ifdef ETLOGGER_JOURNAL
    int priority = LOG_DEBUG;

    switch (dmesg.type()) {
    case QtDebugMsg:
        priority = LOG_DEBUG;
        break;
    case QtWarningMsg:
        priority = LOG_WARNING;
        break;
    case QtCriticalMsg:
        priority = LOG_ERR;
        break;
    case QtFatalMsg:
        priority = LOG_EMERG;
        break;
    case QtInfoMsg:
        priority = LOG_INFO;
        break;
    default:
        return;
    }

    const auto &file = QByteArrayLiteral("CODE_FILE=") + QByteArray(dmesg.file());
    const auto &line = QByteArrayLiteral("CODE_LINE=") + QByteArray::number(dmesg.line());

    sd_journal_print_with_location(priority, file.constData(), line.constData(), dmesg.function(),
                                   "%s", qPrintable(dmesg.formattedMessage()));

    sd_journal_send_with_location(file.constData(), line.constData(), dmesg.function(), "%s",
                                  qPrintable(dmesg.formattedMessage()), "PRIORITY=%i", priority,
                                  "CATEGORY=%s", dmesg.category(), NULL);
#else
    Q_UNUSED(dmesg);
#endif
}

} // namespace logger
} // namespace et

#endif // ETLOGGER_JOURNAL

// rotatingfilesink.cpp

#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QRegularExpression>

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
RotatingFileSink::RotatingFileSink(const QString &path, int maxFileSize, int maxFileCount)
    : FileSink(path), m_maxFileSize(maxFileSize), m_maxFileCount(maxFileCount)
{
    if (file()->size() > 0)
        rotate();
}

ETLOGGER_DECL_SPEC
void RotatingFileSink::send(const DebugMessage &dmesg)
{
    const auto newFileSize = file()->size() + dmesg.formattedMessage().toLocal8Bit().size();

    if (m_maxFileSize > 0 && file()->size() != 0 && newFileSize > m_maxFileSize) {
        rotate();
    }

    FileSink::send(dmesg);
}

ETLOGGER_DECL_SPEC
QString numberedFileName(const QString &fileName, int i)
{
    return QStringLiteral("%1.%2").arg(fileName).arg(i);
}

ETLOGGER_DECL_SPEC
void RotatingFileSink::rotate()
{
    if (m_maxFileCount == 1)
        return;

    int maxFileCount = m_maxFileCount > 1 ? m_maxFileCount : RotatingFileCountLimit;

    file()->close();

    const auto &fileName = file()->fileName();

    int i = 1;
    for (; i < maxFileCount; ++i) {
        if (!QFile::exists(numberedFileName(fileName, i))) {
            --i;
            break;
        }
    }
    for (; i > 0; --i) {
        const auto &curFileName = numberedFileName(fileName, i);
        const auto &newFileName = numberedFileName(fileName, i + 1);

        QFile::rename(curFileName, newFileName);
    }

    // rename first
    QFile::rename(fileName, numberedFileName(fileName, 1));

    // remove last
    QFile::remove(QStringLiteral("%1.%2").arg(fileName).arg(m_maxFileCount));

    file()->open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text);
}

} // namespace logger
} // namespace et

// signalsink.cpp

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
SignalSink::SignalSink(QObject *parent) : QObject(parent)
{
    setPreprocessor(DefaultFormatter::instance());
}

ETLOGGER_DECL_SPEC
void SignalSink::send(const DebugMessage &dmesg)
{
    emit message(dmesg);
}

} // namespace logger
} // namespace et

// stderrsink.cpp

#include <iostream>

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
StdErrSink::StdErrSink()
{
    setPreprocessor(DefaultFormatter::instance());
}

ETLOGGER_DECL_SPEC
void StdErrSink::send(const DebugMessage &dmesg)
{
    std::cerr << qPrintable(dmesg.formattedMessage()) << std::endl;
}

} // namespace logger
} // namespace et

// stdoutsink.cpp

#include <iostream>

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
StdOutSink::StdOutSink()
{
    setPreprocessor(DefaultFormatter::instance());
}

ETLOGGER_DECL_SPEC
void StdOutSink::send(const DebugMessage &dmesg)
{
    std::cout << qPrintable(dmesg.formattedMessage()) << std::endl;
}

} // namespace logger
} // namespace et

// syslogsink.cpp

#ifdef ETLOGGER_SYSLOG

#ifdef ETLOGGER_SYSLOG
#    include <syslog.h>
#endif

namespace et {
namespace logger {

ETLOGGER_DECL_SPEC
SysLogSink::SysLogSink(const QString &ident, int option, int facility)
{
#ifdef ETLOGGER_SYSLOG
    openlog(qPrintable(ident), option, facility);
#else
    Q_UNUSED(ident);
    Q_UNUSED(option);
    Q_UNUSED(facility);
#endif
}

ETLOGGER_DECL_SPEC
SysLogSink::~SysLogSink()
{
#ifdef ETLOGGER_SYSLOG
    closelog();
#endif
}

ETLOGGER_DECL_SPEC
void SysLogSink::send(const DebugMessage &dmesg)
{
#ifdef ETLOGGER_SYSLOG
    QString formattedMessage;
    if (qstrcmp(dmesg.category(), "default") == 0)
        formattedMessage = dmesg.message();
    else
        formattedMessage = QStringLiteral("%1: %2").arg(dmesg.category(), dmesg.message());

    int priority = LOG_DEBUG;

    switch (dmesg.type()) {
    case QtDebugMsg:
        priority = LOG_DEBUG;
        break;
    case QtWarningMsg:
        priority = LOG_WARNING;
        break;
    case QtCriticalMsg:
        priority = LOG_ERR;
        break;
    case QtFatalMsg:
        priority = LOG_EMERG;
        break;
    case QtInfoMsg:
        priority = LOG_INFO;
        break;
    default:
        return;
    }

    syslog(priority, "%s", qPrintable(formattedMessage));
#else
    Q_UNUSED(dmesg);
#endif
}

} // namespace logger
} // namespace et

#endif // ETLOGGER_SYSLOG

